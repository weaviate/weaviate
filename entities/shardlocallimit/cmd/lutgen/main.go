//                           _       _
// __      _____  __ ___   ___  __ _| |_ ___
// \ \ /\ / / _ \/ _` \ \ / / |/ _` | __/ _ \
//  \ V  V /  __/ (_| |\ V /| | (_| | ||  __/
//   \_/\_/ \___|\__,_| \_/ |_|\__,_|\__\___|
//
//  Copyright Â© 2016 - 2026 Weaviate B.V. All rights reserved.
//
//  CONTACT: hello@weaviate.io
//

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"math"
	"os"
	"path/filepath"
	"time"
)

const (
	targetSuccess = 0.99999 // 99.999%
)

// Keep in sync with locallimit/lut.go
var (
	shardBuckets = []int{1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 15, 20, 25, 30, 40, 50, 75, 100}
	limitBuckets = []int{10, 25, 50, 75, 100, 200, 400, 800, 1000, 2500, 5000, 7500, 10000}
)

func main() {
	var out string
	flag.StringVar(&out, "out", "local_limit_lut_gen.go", "output .go file (relative to locallimit package dir)")
	flag.Parse()

	// Build LUT: [len(shardBuckets)][len(limitBuckets)]uint16
	lut := make([][]uint16, len(shardBuckets))
	for si, S := range shardBuckets {
		row := make([]uint16, len(limitBuckets))
		for li, L := range limitBuckets {
			k := localLimitUnionBound(S, L, targetSuccess)
			if k < 0 {
				k = 0
			}
			if k > math.MaxUint16 {
				// For these ranges (L<=10000) this should not happen,
				// but be defensive.
				k = math.MaxUint16
			}
			row[li] = uint16(k)
		}
		lut[si] = row
	}

	src := renderGo(lut)

	formatted, err := format.Source(src)
	if err != nil {
		// If formatting fails, write raw source for debugging.
		_ = os.WriteFile(out, src, 0o644)
		panic(fmt.Errorf("gofmt failed: %w (wrote unformatted output to %s)", err, out))
	}

	// Ensure output directory exists
	if dir := filepath.Dir(out); dir != "." {
		_ = os.MkdirAll(dir, 0o755)
	}

	if err := os.WriteFile(out, formatted, 0o644); err != nil {
		panic(err)
	}
}

func renderGo(lut [][]uint16) []byte {
	var b bytes.Buffer

	fmt.Fprintf(&b, "// Code generated by %s; DO NOT EDIT.\n", filepath.Base(os.Args[0]))
	fmt.Fprintf(&b, "// Generated at: %s\n", time.Now().UTC().Format(time.RFC3339))
	fmt.Fprintf(&b, "//\n")
	fmt.Fprintf(&b, "// Target success probability: %.6f (miss <= %.6g)\n", targetSuccess, 1.0-targetSuccess)
	fmt.Fprintf(&b, "// Model/criterion used:\n")
	fmt.Fprintf(&b, "//   Let X ~ Binomial(L, 1/S). Using union bound:\n")
	fmt.Fprintf(&b, "//     P(max shard load > k) <= S * P(X > k)\n")
	fmt.Fprintf(&b, "//   Choose minimal k such that:\n")
	fmt.Fprintf(&b, "//     S * P(X > k) <= (1 - targetSuccess)\n")
	fmt.Fprintf(&b, "//\n")
	fmt.Fprintf(&b, "package shardlocallimit\n\n")

	fmt.Fprintf(&b, "var localLimitLUT = [][]uint16{\n")
	for _, row := range lut {
		fmt.Fprintf(&b, "\t{")
		for j, v := range row {
			if j > 0 {
				fmt.Fprintf(&b, ", ")
			}
			fmt.Fprintf(&b, "%d", v)
		}
		fmt.Fprintf(&b, "},\n")
	}
	fmt.Fprintf(&b, "}\n")

	return b.Bytes()
}

// localLimitUnionBound finds the minimal k such that:
//
//	S * P(Binomial(L, 1/S) > k) <= (1 - target)
//
// This is conservative for the multinomial max-load event but fast and stable.
func localLimitUnionBound(S, L int, target float64) int {
	if S <= 0 || L <= 0 {
		return 0
	}
	if target <= 0 {
		return int(math.Ceil(float64(L) / float64(S)))
	}
	if target >= 1 {
		return L
	}

	p := 1.0 / float64(S)
	delta := 1.0 - target
	perShard := delta / float64(S)

	lo := int(math.Ceil(float64(L) / float64(S))) // pigeonhole lower bound
	hi := L

	for lo < hi {
		mid := (lo + hi) / 2
		if binomTailGTRec(L, mid, p) <= perShard {
			hi = mid
		} else {
			lo = mid + 1
		}
	}
	return lo
}

// binomTailGTRec computes P(X > k) for X~Binomial(n,p).
// It uses one lgamma-based seed for pmf at i=k+1 and then a recurrence to avoid lgamma in the loop.
// This is fast and numerically stable for the thresholds we care about (<= 1e-5 / S).
func binomTailGTRec(n, k int, p float64) float64 {
	if k < 0 {
		return 1
	}
	if k >= n {
		return 0
	}
	if p <= 0 {
		return 0
	}
	if p >= 1 {
		if k < n {
			return 1
		}
		return 0
	}

	q := 1.0 - p

	i := k + 1
	logPMF := logChoose(n, i) + float64(i)*math.Log(p) + float64(n-i)*math.Log(q)
	pmf := math.Exp(logPMF)
	if pmf == 0 {
		return 0
	}

	sum := pmf
	r := p / q

	// pmf(i+1) = pmf(i) * ((n - i) / (i+1)) * (p/(1-p))
	for ; i < n; i++ {
		pmf *= (float64(n-i) / float64(i+1)) * r
		sum += pmf

		// Early stop once additional terms cannot change sum at float64 resolution.
		if pmf < sum*1e-16 {
			break
		}
	}

	if sum < 0 {
		return 0
	}
	if sum > 1 {
		return 1
	}
	return sum
}

func logChoose(n, k int) float64 {
	if k < 0 || k > n {
		return math.Inf(-1)
	}
	if k > n-k {
		k = n - k
	}
	return lgamma(float64(n)+1) - lgamma(float64(k)+1) - lgamma(float64(n-k)+1)
}

func lgamma(x float64) float64 {
	v, _ := math.Lgamma(x)
	return v
}
