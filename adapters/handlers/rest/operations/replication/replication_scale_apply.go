//                           _       _
// __      _____  __ ___   ___  __ _| |_ ___
// \ \ /\ / / _ \/ _` \ \ / / |/ _` | __/ _ \
//  \ V  V /  __/ (_| |\ V /| | (_| | ||  __/
//   \_/\_/ \___|\__,_| \_/ |_|\__,_|\__\___|
//
//  Copyright Â© 2016 - 2024 Weaviate B.V. All rights reserved.
//
//  CONTACT: hello@weaviate.io
//

// Code generated by go-swagger; DO NOT EDIT.

package replication

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"

	"github.com/weaviate/weaviate/entities/models"
)

// ReplicationScaleApplyHandlerFunc turns a function with the right signature into a replication scale apply handler
type ReplicationScaleApplyHandlerFunc func(ReplicationScaleApplyParams, *models.Principal) middleware.Responder

// Handle executing the request and returning a response
func (fn ReplicationScaleApplyHandlerFunc) Handle(params ReplicationScaleApplyParams, principal *models.Principal) middleware.Responder {
	return fn(params, principal)
}

// ReplicationScaleApplyHandler interface for that can handle valid replication scale apply params
type ReplicationScaleApplyHandler interface {
	Handle(ReplicationScaleApplyParams, *models.Principal) middleware.Responder
}

// NewReplicationScaleApply creates a new http.Handler for the replication scale apply operation
func NewReplicationScaleApply(ctx *middleware.Context, handler ReplicationScaleApplyHandler) *ReplicationScaleApply {
	return &ReplicationScaleApply{Context: ctx, Handler: handler}
}

/*
	ReplicationScaleApply swagger:route POST /replication/scale replication replicationScaleApply

# Apply replication scaling based on provided sharding state

Receives a desired ReplicationShardingState and performs scaling operations by assigning or removing replicas on shards as necessary, based on the difference between the current and provided sharding states. Shard creation tasks are tracked and returned as operation IDs. Shard drop tasks are applied immediately and are not tracked.
*/
type ReplicationScaleApply struct {
	Context *middleware.Context
	Handler ReplicationScaleApplyHandler
}

func (o *ReplicationScaleApply) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewReplicationScaleApplyParams()
	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		*r = *aCtx
	}
	var principal *models.Principal
	if uprinc != nil {
		principal = uprinc.(*models.Principal) // this is really a models.Principal, I promise
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
