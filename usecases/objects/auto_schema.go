//                           _       _
// __      _____  __ ___   ___  __ _| |_ ___
// \ \ /\ / / _ \/ _` \ \ / / |/ _` | __/ _ \
//  \ V  V /  __/ (_| |\ V /| | (_| | ||  __/
//   \_/\_/ \___|\__,_| \_/ |_|\__,_|\__\___|
//
//  Copyright Â© 2016 - 2023 Weaviate B.V. All rights reserved.
//
//  CONTACT: hello@weaviate.io
//

package objects

import (
	"context"
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/sirupsen/logrus"
	"github.com/weaviate/weaviate/entities/additional"
	"github.com/weaviate/weaviate/entities/models"
	"github.com/weaviate/weaviate/entities/schema"
	"github.com/weaviate/weaviate/entities/schema/crossref"
	"github.com/weaviate/weaviate/entities/search"
	"github.com/weaviate/weaviate/usecases/config"
	"github.com/weaviate/weaviate/usecases/objects/validation"
)

type autoSchemaManager struct {
	mutex         sync.RWMutex
	schemaManager schemaManager
	vectorRepo    VectorRepo
	config        config.AutoSchema
	logger        logrus.FieldLogger
}

func newAutoSchemaManager(schemaManager schemaManager, vectorRepo VectorRepo,
	config *config.WeaviateConfig, logger logrus.FieldLogger,
) *autoSchemaManager {
	return &autoSchemaManager{
		schemaManager: schemaManager,
		vectorRepo:    vectorRepo,
		config:        config.Config.AutoSchema,
		logger:        logger,
	}
}

func (m *autoSchemaManager) autoSchema(ctx context.Context, principal *models.Principal,
	object *models.Object,
) error {
	if m.config.Enabled {
		return m.performAutoSchema(ctx, principal, object)
	}
	return nil
}

func (m *autoSchemaManager) performAutoSchema(ctx context.Context, principal *models.Principal,
	object *models.Object,
) error {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	if object == nil {
		return fmt.Errorf(validation.ErrorMissingObject)
	}

	if len(object.Class) == 0 {
		// stop performing auto schema
		return fmt.Errorf(validation.ErrorMissingClass)
	}

	object.Class = schema.UppercaseClassName(object.Class)

	schemaClass, err := m.getClass(principal, object)
	if err != nil {
		return err
	}
	properties := m.getProperties(object)
	if schemaClass == nil {
		return m.createClass(ctx, principal, object.Class, properties)
	}
	return m.updateClass(ctx, principal, object.Class, properties, schemaClass.Properties)
}

func (m *autoSchemaManager) getClass(principal *models.Principal,
	object *models.Object,
) (*models.Class, error) {
	s, err := m.schemaManager.GetSchema(principal)
	if err != nil {
		return nil, err
	}
	schemaClass := s.GetClass(schema.ClassName(object.Class))
	return schemaClass, nil
}

func (m *autoSchemaManager) createClass(ctx context.Context, principal *models.Principal,
	className string, properties []*models.Property,
) error {
	now := time.Now()
	class := &models.Class{
		Class:       className,
		Properties:  properties,
		Description: "This property was generated by Weaviate's auto-schema feature on " + now.Format(time.ANSIC),
	}
	m.logger.
		WithField("auto_schema", "createClass").
		Debugf("create class %s", className)
	return m.schemaManager.AddClass(ctx, principal, class)
}

func (m *autoSchemaManager) updateClass(ctx context.Context, principal *models.Principal,
	className string, properties []*models.Property, existingProperties []*models.Property,
) error {
	existingPropertiesIndexMap := map[string]int{}
	for index := range existingProperties {
		existingPropertiesIndexMap[existingProperties[index].Name] = index
	}

	propertiesToAdd := []*models.Property{}
	propertiesToUpdate := []*models.Property{}
	for _, prop := range properties {
		index, exists := existingPropertiesIndexMap[schema.LowercaseFirstLetter(prop.Name)]
		if !exists {
			propertiesToAdd = append(propertiesToAdd, prop)
		} else if _, isNested := schema.AsNested(existingProperties[index].DataType); isNested {
			mergedNestedProperties, merged := schema.MergeRecursivelyNestedProperties(existingProperties[index].NestedProperties,
				prop.NestedProperties)
			if merged {
				prop.NestedProperties = mergedNestedProperties
				propertiesToUpdate = append(propertiesToUpdate, prop)
			}
		}
	}
	for _, newProp := range propertiesToAdd {
		m.logger.
			WithField("auto_schema", "updateClass").
			Debugf("update class %s add property %s", className, newProp.Name)
		err := m.schemaManager.AddClassProperty(ctx, principal, className, newProp)
		if err != nil {
			return err
		}
	}
	for _, updatedProp := range propertiesToUpdate {
		m.logger.
			WithField("auto_schema", "updateClass").
			Debugf("update class %s merge object property %s", className, updatedProp.Name)
		err := m.schemaManager.MergeClassObjectProperty(ctx, principal, className, updatedProp)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *autoSchemaManager) getProperties(object *models.Object) []*models.Property {
	properties := []*models.Property{}
	if props, ok := object.Properties.(map[string]interface{}); ok {
		for name, value := range props {
			now := time.Now()
			dt := m.determineType(value, false)

			var nestedProperties []*models.NestedProperty
			if len(dt) == 1 {
				switch dt[0] {
				case schema.DataTypeObject:
					nestedProperties = m.determineNestedProperties(value.(map[string]interface{}), now)
				case schema.DataTypeObjectArray:
					nestedProperties = m.determineNestedPropertiesOfArray(value.([]interface{}), now)
				default:
					// do nothing
				}
			}

			property := &models.Property{
				Name:             name,
				DataType:         m.getDataTypes(dt),
				Description:      "This property was generated by Weaviate's auto-schema feature on " + now.Format(time.ANSIC),
				NestedProperties: nestedProperties,
			}
			properties = append(properties, property)
		}
	}
	return properties
}

func (m *autoSchemaManager) getDataTypes(dataTypes []schema.DataType) []string {
	dtypes := make([]string, len(dataTypes))
	for i := range dataTypes {
		dtypes[i] = string(dataTypes[i])
	}
	return dtypes
}

func (m *autoSchemaManager) determineType(value interface{}, ofNestedProp bool) []schema.DataType {
	fallbackDataType := []schema.DataType{schema.DataTypeText}

	switch v := value.(type) {
	case string:
		_, err := time.Parse(time.RFC3339, v)
		if err == nil {
			return []schema.DataType{schema.DataType(m.config.DefaultDate)}
		}
		if m.config.DefaultString != "" {
			return []schema.DataType{schema.DataType(m.config.DefaultString)}
		}
		return []schema.DataType{schema.DataTypeText}
	case json.Number:
		return []schema.DataType{schema.DataType(m.config.DefaultNumber)}
	case bool:
		return []schema.DataType{schema.DataTypeBoolean}
	case map[string]interface{}:
		if dt, ok := m.asGeoCoordinatesType(v); ok {
			return dt
		}
		if dt, ok := m.asPhoneNumber(v); ok {
			return dt
		}
		return []schema.DataType{schema.DataTypeObject}
	case []interface{}:
		if len(v) > 0 {
			dataType := []schema.DataType{}
			for i := range v {
				switch arrayVal := v[i].(type) {
				case map[string]interface{}:
					if ofNestedProp {
						return []schema.DataType{schema.DataTypeObjectArray}
					}
					if dt, ok := m.asRef(arrayVal); ok {
						dataType = append(dataType, dt)
					} else {
						return []schema.DataType{schema.DataTypeObjectArray}
					}
				case string:
					_, err := time.Parse(time.RFC3339, arrayVal)
					if err == nil {
						return []schema.DataType{schema.DataTypeDateArray}
					}
					if schema.DataType(m.config.DefaultString) == schema.DataTypeString {
						return []schema.DataType{schema.DataTypeStringArray}
					}
					return []schema.DataType{schema.DataTypeTextArray}
				case json.Number:
					if schema.DataType(m.config.DefaultNumber) == schema.DataTypeInt {
						return []schema.DataType{schema.DataTypeIntArray}
					}
					return []schema.DataType{schema.DataTypeNumberArray}
				case bool:
					return []schema.DataType{schema.DataTypeBooleanArray}
				}
			}
			if len(dataType) == 0 {
				return fallbackDataType
			}
			return dataType
		}
		return fallbackDataType
	default:
		return fallbackDataType
	}
}

func (m *autoSchemaManager) asGeoCoordinatesType(val map[string]interface{}) ([]schema.DataType, bool) {
	if len(val) == 2 {
		if val["latitude"] != nil && val["longitude"] != nil {
			return []schema.DataType{schema.DataTypeGeoCoordinates}, true
		}
	}
	return nil, false
}

func (m *autoSchemaManager) asPhoneNumber(val map[string]interface{}) ([]schema.DataType, bool) {
	if val["input"] != nil {
		if len(val) == 1 {
			return []schema.DataType{schema.DataTypePhoneNumber}, true
		}
		if len(val) == 2 {
			if _, ok := val["defaultCountry"]; ok {
				return []schema.DataType{schema.DataTypePhoneNumber}, true
			}
		}
	}

	return nil, false
}

func (m *autoSchemaManager) asRef(val map[string]interface{}) (schema.DataType, bool) {
	if v, ok := val["beacon"]; ok {
		if beacon, ok := v.(string); ok {
			ref, err := crossref.Parse(beacon)
			if err == nil {
				if ref.Class == "" {
					res, err := m.vectorRepo.ObjectByID(context.Background(), ref.TargetID, search.SelectProperties{}, additional.Properties{}, "")
					if err == nil && res != nil {
						return schema.DataType(res.ClassName), true
					}
				} else {
					return schema.DataType(ref.Class), true
				}
			}
		}
	}
	return "", false
}

func (m *autoSchemaManager) determineNestedProperties(values map[string]interface{}, now time.Time) []*models.NestedProperty {
	i := 0
	nestedProperties := make([]*models.NestedProperty, len(values))
	for name, value := range values {
		nestedProperties[i] = m.determineNestedProperty(name, value, now)
		i++
	}
	return nestedProperties
}

func (m *autoSchemaManager) determineNestedProperty(name string, value interface{}, now time.Time) *models.NestedProperty {
	dt := m.determineType(value, true)

	var np []*models.NestedProperty
	if len(dt) == 1 {
		switch dt[0] {
		case schema.DataTypeObject:
			np = m.determineNestedProperties(value.(map[string]interface{}), now)
		case schema.DataTypeObjectArray:
			np = m.determineNestedPropertiesOfArray(value.([]interface{}), now)
		default:
			// do nothing
		}
	}

	return &models.NestedProperty{
		Name:             name,
		DataType:         m.getDataTypes(dt),
		Description:      "This nested property was generated by Weaviate's auto-schema feature on " + now.Format(time.ANSIC),
		NestedProperties: np,
	}
}

func (m *autoSchemaManager) determineNestedPropertiesOfArray(valArray []interface{}, now time.Time) []*models.NestedProperty {
	if len(valArray) == 0 {
		return []*models.NestedProperty{}
	}
	nestedProperties := m.determineNestedProperties(valArray[0].(map[string]interface{}), now)
	if len(valArray) == 1 {
		return nestedProperties
	}

	nestedPropertiesIndexMap := map[string]int{}
	for index := range nestedProperties {
		nestedPropertiesIndexMap[nestedProperties[index].Name] = index
	}

	for i := 1; i < len(valArray); i++ {
		values := valArray[i].(map[string]interface{})
		for name, value := range values {
			index, ok := nestedPropertiesIndexMap[name]
			if !ok {
				nestedPropertiesIndexMap[name] = len(nestedProperties)
				nestedProperties = append(nestedProperties, m.determineNestedProperty(name, value, now))
			} else if _, isNested := schema.AsNested(nestedProperties[index].DataType); isNested {
				if mergedNestedProperties, merged := schema.MergeRecursivelyNestedProperties(
					nestedProperties[index].NestedProperties,
					m.determineNestedProperty(name, value, now).NestedProperties,
				); merged {
					nestedProperties[index].NestedProperties = mergedNestedProperties
				}
			}
		}
	}

	return nestedProperties
}
