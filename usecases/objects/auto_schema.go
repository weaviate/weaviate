//                           _       _
// __      _____  __ ___   ___  __ _| |_ ___
// \ \ /\ / / _ \/ _` \ \ / / |/ _` | __/ _ \
//  \ V  V /  __/ (_| |\ V /| | (_| | ||  __/
//   \_/\_/ \___|\__,_| \_/ |_|\__,_|\__\___|
//
//  Copyright Â© 2016 - 2023 Weaviate B.V. All rights reserved.
//
//  CONTACT: hello@weaviate.io
//

package objects

import (
	"context"
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/sirupsen/logrus"
	"github.com/weaviate/weaviate/entities/additional"
	"github.com/weaviate/weaviate/entities/models"
	"github.com/weaviate/weaviate/entities/schema"
	"github.com/weaviate/weaviate/entities/schema/crossref"
	"github.com/weaviate/weaviate/entities/search"
	"github.com/weaviate/weaviate/usecases/config"
	"github.com/weaviate/weaviate/usecases/objects/validation"
)

type autoSchemaManager struct {
	mutex         sync.RWMutex
	schemaManager schemaManager
	vectorRepo    VectorRepo
	config        config.AutoSchema
	logger        logrus.FieldLogger
}

func newAutoSchemaManager(schemaManager schemaManager, vectorRepo VectorRepo,
	config *config.WeaviateConfig, logger logrus.FieldLogger,
) *autoSchemaManager {
	return &autoSchemaManager{
		schemaManager: schemaManager,
		vectorRepo:    vectorRepo,
		config:        config.Config.AutoSchema,
		logger:        logger,
	}
}

func (m *autoSchemaManager) autoSchema(ctx context.Context, principal *models.Principal,
	object *models.Object,
) error {
	if m.config.Enabled {
		return m.performAutoSchema(ctx, principal, object)
	}
	return nil
}

func (m *autoSchemaManager) performAutoSchema(ctx context.Context, principal *models.Principal,
	object *models.Object,
) error {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	if object == nil {
		return fmt.Errorf(validation.ErrorMissingObject)
	}

	if len(object.Class) == 0 {
		// stop performing auto schema
		return fmt.Errorf(validation.ErrorMissingClass)
	}

	object.Class = schema.UppercaseClassName(object.Class)

	schemaClass, err := m.getClass(principal, object)
	if err != nil {
		return err
	}
	properties := m.getProperties(object)
	if schemaClass == nil {
		return m.createClass(ctx, principal, object.Class, properties)
	}
	return m.updateClass(ctx, principal, object.Class, properties, schemaClass.Properties)
}

func (m *autoSchemaManager) getClass(principal *models.Principal,
	object *models.Object,
) (*models.Class, error) {
	s, err := m.schemaManager.GetSchema(principal)
	if err != nil {
		return nil, err
	}
	schemaClass := s.GetClass(schema.ClassName(object.Class))
	return schemaClass, nil
}

func (m *autoSchemaManager) createClass(ctx context.Context, principal *models.Principal,
	className string, properties []*models.Property,
) error {
	now := time.Now()
	class := &models.Class{
		Class:       className,
		Properties:  properties,
		Description: "This property was generated by Weaviate's auto-schema feature on " + now.Format(time.ANSIC),
	}
	m.logger.
		WithField("auto_schema", "createClass").
		Debugf("create class %s", className)
	return m.schemaManager.AddClass(ctx, principal, class)
}

func (m *autoSchemaManager) updateClass(ctx context.Context, principal *models.Principal,
	className string, properties []*models.Property, existingProperties []*models.Property,
) error {
	propertiesToAdd := []*models.Property{}
	for _, prop := range properties {
		found := false
		for _, classProp := range existingProperties {
			if classProp.Name == schema.LowercaseFirstLetter(prop.Name) {
				found = true
				break
			}
		}
		if !found {
			propertiesToAdd = append(propertiesToAdd, prop)
		}
	}
	for _, newProp := range propertiesToAdd {
		m.logger.
			WithField("auto_schema", "updateClass").
			Debugf("update class %s add property %s", className, newProp.Name)
		err := m.schemaManager.AddClassProperty(ctx, principal, className, newProp)
		if err != nil {
			return err
		}
	}
	return nil
}

func (m *autoSchemaManager) getProperties(object *models.Object) []*models.Property {
	properties := []*models.Property{}
	if props, ok := object.Properties.(map[string]interface{}); ok {
		for name, value := range props {
			dt := m.determineType(value)
			now := time.Now()
			property := &models.Property{
				Name:        name,
				DataType:    m.getDataTypes(dt),
				Description: "This property was generated by Weaviate's auto-schema feature on " + now.Format(time.ANSIC),
			}
			properties = append(properties, property)
		}
	}
	return properties
}

func (m *autoSchemaManager) getDataTypes(dataTypes []schema.DataType) []string {
	dtypes := make([]string, len(dataTypes))
	for i := range dataTypes {
		dtypes[i] = string(dataTypes[i])
	}
	return dtypes
}

func (m *autoSchemaManager) determineType(value interface{}) []schema.DataType {
	fallbackDataType := []schema.DataType{schema.DataTypeText}

	switch v := value.(type) {
	case string:
		_, err := time.Parse(time.RFC3339, v)
		if err == nil {
			return []schema.DataType{schema.DataType(m.config.DefaultDate)}
		}
		if m.config.DefaultString != "" {
			return []schema.DataType{schema.DataType(m.config.DefaultString)}
		}
		return []schema.DataType{schema.DataTypeText}
	case json.Number:
		return []schema.DataType{schema.DataType(m.config.DefaultNumber)}
	case bool:
		return []schema.DataType{schema.DataTypeBoolean}
	case map[string]interface{}:
		if v["latitude"] != nil && v["longitude"] != nil {
			return []schema.DataType{schema.DataTypeGeoCoordinates}
		}
		if v["input"] != nil {
			return []schema.DataType{schema.DataTypePhoneNumber}
		}
		return fallbackDataType
	case []interface{}:
		if len(v) > 0 {
			dataType := []schema.DataType{}
			for i := range v {
				switch arrayVal := v[i].(type) {
				case map[string]interface{}:
					if len(arrayVal) > 0 {
						for k, v := range arrayVal {
							if k == "beacon" {
								if beacon, ok := v.(string); ok {
									ref, err := crossref.Parse(beacon)
									if err == nil {
										if ref.Class == "" {
											res, err := m.vectorRepo.ObjectByID(context.Background(), ref.TargetID,
												search.SelectProperties{}, additional.Properties{})
											if err == nil && res != nil {
												dataType = append(dataType, schema.DataType(res.ClassName))
											}
										} else {
											dataType = append(dataType, schema.DataType(ref.Class))
										}
									}
								}
							}
						}
					}
				case string:
					_, err := time.Parse(time.RFC3339, arrayVal)
					if err == nil {
						return []schema.DataType{schema.DataTypeDateArray}
					}
					if schema.DataType(m.config.DefaultString) == schema.DataTypeString {
						return []schema.DataType{schema.DataTypeStringArray}
					}
					return []schema.DataType{schema.DataTypeTextArray}
				case json.Number:
					if schema.DataType(m.config.DefaultNumber) == schema.DataTypeInt {
						return []schema.DataType{schema.DataTypeIntArray}
					}
					return []schema.DataType{schema.DataTypeNumberArray}
				case bool:
					return []schema.DataType{schema.DataTypeBooleanArray}
				}
			}
			return dataType
		}
		return fallbackDataType
	default:
		return fallbackDataType
	}
}
