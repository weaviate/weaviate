package objects

import (
	"context"
	"fmt"

	"github.com/semi-technologies/weaviate/adapters/repos/db/vector/hnsw"
	"github.com/semi-technologies/weaviate/entities/models"
	"github.com/semi-technologies/weaviate/usecases/config"
	"github.com/sirupsen/logrus"
)

type obtainerValidator interface {
	SchemaManager() schemaManager
	Logger() logrus.FieldLogger
}

func validateVectorizer(ov obtainerValidator,
	principal *models.Principal, obj *models.Object,
) (vectorizerName string, err error) {
	vectorizerName, cfg, err := getVectorizerOfClass(ov.SchemaManager(), obj.Class, principal)
	if err != nil {
		err = fmt.Errorf("get vectorizer for class %q: %w", obj.Class, err)
		return
	}

	hnswConfig, ok := cfg.(hnsw.UserConfig)
	if !ok {
		err = fmt.Errorf("vector index config (%T) is not of type HNSW, "+
			"but objects manager is restricted to HNSW", cfg)
		return
	}

	if vectorizerName == config.VectorizerModuleNone {
		err = validateVectorPresent(obj, hnswConfig, ov.Logger())
		if err != nil {
			err = NewErrInvalidUserInput("%v", err)
			return
		}

		return
	}

	if hnswConfig.Skip {
		ov.Logger().WithField("className", obj.Class).
			WithField("vectorizer", vectorizerName).
			Warningf("this class is configured to skip vector indexing, "+
				"but a vector was generated by the %q vectorizer. "+
				"This vector will be ignored. If you meant to index "+
				"the vector, make sure to set vectorIndexConfig.skip to 'false'. If the previous "+
				"setting is correct, make sure you set vectorizer to 'none' in the schema and "+
				"provide a null-vector (i.e. no vector) at import time.", vectorizerName)
	}

	return
}

func validateVectorPresent(obj *models.Object,
	hnswConfig hnsw.UserConfig, logger logrus.FieldLogger,
) error {
	if hnswConfig.Skip && len(obj.Vector) > 0 {
		logger.WithField("className", obj.Class).
			Warningf("this class is configured to skip vector indexing, " +
				"but a vector was explicitly provided. " +
				"This vector will be ignored. If you meant to index " +
				"the vector, make sure to set vectorIndexConfig.skip to 'false'. If the previous " +
				"setting is correct, make sure you set vectorizer to 'none' in the schema and " +
				"provide a null-vector (i.e. no vector) at import time.")
	}

	return nil
}

type vectorObtainer struct {
	vectorizerProvider VectorizerProvider
	schemaManager      schemaManager
	logger             logrus.FieldLogger
}

func (vo *vectorObtainer) SchemaManager() schemaManager {
	return vo.schemaManager
}

func (vo *vectorObtainer) Logger() logrus.FieldLogger {
	return vo.logger
}

func newVectorObtainer(vectorizerProvider VectorizerProvider,
	schemaManager schemaManager, logger logrus.FieldLogger,
) *vectorObtainer {
	return &vectorObtainer{
		vectorizerProvider: vectorizerProvider,
		schemaManager:      schemaManager,
		logger:             logger,
	}
}

type referenceVectorObtainer struct {
	referenceVectorizerProvider ReferenceVectorizerProvider
	schemaManager               schemaManager
	logger                      logrus.FieldLogger
}

func (vo *referenceVectorObtainer) SchemaManager() schemaManager {
	return vo.schemaManager
}

func (vo *referenceVectorObtainer) Logger() logrus.FieldLogger {
	return vo.logger
}

func newReferenceVectorObtainer(referenceVectorizerProvider ReferenceVectorizerProvider,
	schemaManager schemaManager, logger logrus.FieldLogger,
) *referenceVectorObtainer {
	return &referenceVectorObtainer{
		referenceVectorizerProvider: referenceVectorizerProvider,
		schemaManager:               schemaManager,
		logger:                      logger,
	}
}

// Do retrieves the correct vector and makes sure it is set on the passed-in
// *models.Object. (This method mutates its parameter)
func (vo *referenceVectorObtainer) Do(ctx context.Context, obj *models.Object,
	principal *models.Principal, refVecs ...[]float32,
) error {
	vectorizerName, err := validateVectorizer(vo, principal, obj)
	if err != nil {
		return err
	}

	if vectorizerName == config.VectorizerModuleNone {
		return nil
	}

	vectorizer, err := vo.referenceVectorizerProvider.ReferenceVectorizer(vectorizerName, obj.Class)
	if err != nil {
		return err
	}

	if err := vectorizer.UpdateObject(ctx, obj, refVecs...); err != nil {
		return NewErrInternal("%v", err)
	}

	return nil
}

// Do retrieves the correct vector and makes sure it is set on the passed-in
// *models.Object. (This method mutates its parameter)
func (vo *vectorObtainer) Do(ctx context.Context, obj *models.Object,
	principal *models.Principal,
) error {
	vectorizerName, err := validateVectorizer(vo, principal, obj)
	if err != nil {
		return err
	}

	if vectorizerName == config.VectorizerModuleNone {
		return nil
	}

	if obj.Vector == nil {
		// a vectorizer is present and indexing is not skipped
		// TODO: before calling the vectorizer we have to check if the user might have
		// overridden the vector
		vectorizer, err := vo.vectorizerProvider.Vectorizer(vectorizerName, obj.Class)
		if err != nil {
			return err
		}

		if err := vectorizer.UpdateObject(ctx, obj); err != nil {
			return NewErrInternal("%v", err)
		}
	}

	return nil
}
