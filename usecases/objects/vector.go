//                           _       _
// __      _____  __ ___   ___  __ _| |_ ___
// \ \ /\ / / _ \/ _` \ \ / / |/ _` | __/ _ \
//  \ V  V /  __/ (_| |\ V /| | (_| | ||  __/
//   \_/\_/ \___|\__,_| \_/ |_|\__,_|\__\___|
//
//  Copyright Â© 2016 - 2022 SeMI Technologies B.V. All rights reserved.
//
//  CONTACT: hello@semi.technology
//

package objects

import (
	"context"
	"fmt"
	"path"

	"github.com/go-openapi/strfmt"
	"github.com/pkg/errors"
	"github.com/semi-technologies/weaviate/adapters/repos/db/vector/hnsw"
	"github.com/semi-technologies/weaviate/entities/additional"
	"github.com/semi-technologies/weaviate/entities/models"
	"github.com/semi-technologies/weaviate/entities/schema"
	"github.com/semi-technologies/weaviate/entities/search"
	"github.com/semi-technologies/weaviate/usecases/config"
	"github.com/sirupsen/logrus"
)

type vectorObtainer struct {
	referenceVectorizerProvider ReferenceVectorizerProvider
	vectorizerProvider          VectorizerProvider
	schemaManager               schemaManager
	logger                      logrus.FieldLogger
}

func newVectorObtainer(vectorizerProvider VectorizerProvider,
	schemaManager schemaManager, logger logrus.FieldLogger,
) *vectorObtainer {
	return &vectorObtainer{
		vectorizerProvider: vectorizerProvider,
		schemaManager:      schemaManager,
		logger:             logger,
	}
}

func newReferenceVectorObtainer(referenceVectorizerProvider ReferenceVectorizerProvider,
	schemaManager schemaManager, logger logrus.FieldLogger,
) *vectorObtainer {
	return &vectorObtainer{
		referenceVectorizerProvider: referenceVectorizerProvider,
		schemaManager:               schemaManager,
		logger:                      logger,
	}
}

// Do retrieves the correct vector and makes sure it is set on the passed-in
// *models.Object. (This method mutates its parameter)
func (vo *vectorObtainer) Do(ctx context.Context, obj *models.Object,
	principal *models.Principal, refVecs ...[]float32,
) error {
	vectorizerName, cfg, err := vo.getVectorizerOfClass(obj.Class, principal)
	if err != nil {
		return err
	}

	hnswConfig, ok := cfg.(hnsw.UserConfig)
	if !ok {
		return errors.Errorf("vector index config (%T) is not of type HNSW, "+
			"but objects manager is restricted to HNSW", cfg)
	}

	if vectorizerName == config.VectorizerModuleNone {
		if err := vo.validateVectorPresent(obj, hnswConfig); err != nil {
			return NewErrInvalidUserInput("%v", err)
		}

		return nil
	}

	if hnswConfig.Skip {
		vo.logger.WithField("className", obj.Class).
			WithField("vectorizer", vectorizerName).
			Warningf("this class is configured to skip vector indexing, "+
				"but a vector was generated by the %q vectorizer. "+
				"This vector will be ignored. If you meant to index "+
				"the vector, make sure to set vectorIndexConfig.skip to 'false'. If the previous "+
				"setting is correct, make sure you set vectorizer to 'none' in the schema and "+
				"provide a null-vector (i.e. no vector) at import time.", vectorizerName)
	}

	if vo.referenceVectorizerProvider != nil {
		vectorizer, err := vo.referenceVectorizerProvider.ReferenceVectorizer(vectorizerName, obj.Class)
		if err != nil {
			return err
		}

		if err := vectorizer.UpdateObject(ctx, obj, refVecs...); err != nil {
			return NewErrInternal("%v", err)
		}
	} else if obj.Vector == nil {
		// a vectorizer is present and indexing is not skipped
		// TODO: before calling the vectorizer we have to check if the user might have
		// overridden the vector
		vectorizer, err := vo.vectorizerProvider.Vectorizer(vectorizerName, obj.Class)
		if err != nil {
			return err
		}

		if err := vectorizer.UpdateObject(ctx, obj); err != nil {
			return NewErrInternal("%v", err)
		}
	}

	return nil
}

func (vo *vectorObtainer) getVectorizerOfClass(className string,
	principal *models.Principal,
) (string, interface{}, error) {
	s, err := vo.schemaManager.GetSchema(principal)
	if err != nil {
		return "", nil, err
	}

	class := s.FindClassByName(schema.ClassName(className))
	if class == nil {
		// this should be impossible by the time this method gets called, but let's
		// be 100% certain
		return "", nil, errors.Errorf("class %s not present", className)
	}

	return class.Vectorizer, class.VectorIndexConfig, nil
}

func (vo *vectorObtainer) validateVectorPresent(obj *models.Object,
	hnswConfig hnsw.UserConfig,
) error {
	if hnswConfig.Skip && len(obj.Vector) > 0 {
		vo.logger.WithField("className", obj.Class).
			Warningf("this class is configured to skip vector indexing, " +
				"but a vector was explicitly provided. " +
				"This vector will be ignored. If you meant to index " +
				"the vector, make sure to set vectorIndexConfig.skip to 'false'. If the previous " +
				"setting is correct, make sure you set vectorizer to 'none' in the schema and " +
				"provide a null-vector (i.e. no vector) at import time.")
	}

	return nil
}

func (m *Manager) computeAndSetReferenceVector(ctx context.Context,
	principal *models.Principal, className string, id strfmt.UUID,
	ref *models.SingleRef,
) error {
	// Get reference properties from module config

	ref2VecPropNames, err := m.modulesProvider.TargetReferenceProperties(className)
	if err != nil {
		return err
	}

	// Find parent

	parent, err := m.vectorRepo.ObjectByID(
		ctx, id, search.SelectProperties{}, additional.Properties{})
	if err != nil {
		return fmt.Errorf("get object by id %q for class %q: %w",
			id, className, err)
	}

	// Get all reference vectors for the object

	refVecs, err := m.getReferenceVectorsFromParent(ctx, parent, ref, ref2VecPropNames)
	if err != nil {
		return nil
	}

	// Compute and set the reference vector

	err = m.vectorizeAndPutObject(ctx, parent.Object(), principal, refVecs...)
	if err != nil {
		return fmt.Errorf("compute reference vector for id %q: %w", id, err)
	}

	return nil
}

func (m *Manager) getReferenceVectorsFromParent(ctx context.Context,
	parent *search.Result, ref *models.SingleRef,
	referencePropNames map[string]struct{},
) (refVecs [][]float32, err error) {
	allProps := parent.Schema.(map[string]interface{})

	// use the ids from parent's beacons to find the referenced objects
	beacons := beaconsForVectorization(allProps, ref, referencePropNames)
	for _, beacon := range beacons {
		res, searchErr := m.vectorRepo.ObjectByID(ctx, strfmt.UUID(path.Base(beacon)),
			search.SelectProperties{}, additional.Properties{})
		if searchErr != nil {
			err = fmt.Errorf("find object with beacon %q': %w", beacon, searchErr)
			return
		}

		// if the ref'd object has a vector, we grab it.
		// these will be used to compute the parent's
		// vector eventually
		if res.Vector != nil {
			refVecs = append(refVecs, res.Vector)
		}
	}

	return
}

func (m *Manager) vectorizeAndPutObject(ctx context.Context, object *models.Object,
	principal *models.Principal, refVecs ...[]float32,
) error {
	if m.modulesProvider.UsingRef2Vec() {
		err := newReferenceVectorObtainer(m.referenceVectorProvider, m.schemaManager,
			m.logger).Do(ctx, object, principal, refVecs...)
		if err != nil {
			return err
		}
	} else {
		err := newVectorObtainer(m.vectorizerProvider, m.schemaManager,
			m.logger).Do(ctx, object, principal)
		if err != nil {
			return err
		}

	}

	err := m.vectorRepo.PutObject(ctx, object, object.Vector)
	if err != nil {
		return NewErrInternal("store: %v", err)
	}

	return nil
}

// beaconsForVectorization filters an objects properties for those which
// are targeted by ref2vec. when such a prop is found, we grab its beacon
// so that we can use the contained id for finding the referenced objects
// later
func beaconsForVectorization(allProps map[string]interface{},
	incomingRef *models.SingleRef, targetRefProps map[string]struct{},
) []string {
	var beacons []string

	if incomingRef != nil {
		beacons = []string{incomingRef.Beacon.String()}
	}

	for prop, val := range allProps {
		if _, ok := targetRefProps[prop]; ok {
			refs := val.(models.MultipleRef)
			for _, ref := range refs {
				beacons = append(beacons, ref.Beacon.String())
			}
		}
	}

	return beacons
}
