//                           _       _
// __      _____  __ ___   ___  __ _| |_ ___
// \ \ /\ / / _ \/ _` \ \ / / |/ _` | __/ _ \
//  \ V  V /  __/ (_| |\ V /| | (_| | ||  __/
//   \_/\_/ \___|\__,_| \_/ |_|\__,_|\__\___|
//
//  Copyright Â© 2016 - 2024 Weaviate B.V. All rights reserved.
//
//  CONTACT: hello@weaviate.io
//

// Code generated by mockery v2.53.2. DO NOT EDIT.

package types

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	models "github.com/weaviate/weaviate/entities/models"

	schema "github.com/weaviate/weaviate/cluster/schema"

	sharding "github.com/weaviate/weaviate/usecases/sharding"

	versioned "github.com/weaviate/weaviate/entities/versioned"
)

// SchemaReader is an autogenerated mock type for the SchemaReader type
type SchemaReader struct {
	mock.Mock
}

type SchemaReader_Expecter struct {
	mock *mock.Mock
}

func (_m *SchemaReader) EXPECT() *SchemaReader_Expecter {
	return &SchemaReader_Expecter{mock: &_m.Mock}
}

// ClassEqual provides a mock function with given fields: name
func (_m *SchemaReader) ClassEqual(name string) string {
	ret := _m.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for ClassEqual")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// SchemaReader_ClassEqual_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClassEqual'
type SchemaReader_ClassEqual_Call struct {
	*mock.Call
}

// ClassEqual is a helper method to define mock.On call
//   - name string
func (_e *SchemaReader_Expecter) ClassEqual(name interface{}) *SchemaReader_ClassEqual_Call {
	return &SchemaReader_ClassEqual_Call{Call: _e.mock.On("ClassEqual", name)}
}

func (_c *SchemaReader_ClassEqual_Call) Run(run func(name string)) *SchemaReader_ClassEqual_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *SchemaReader_ClassEqual_Call) Return(_a0 string) *SchemaReader_ClassEqual_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SchemaReader_ClassEqual_Call) RunAndReturn(run func(string) string) *SchemaReader_ClassEqual_Call {
	_c.Call.Return(run)
	return _c
}

// ClassInfo provides a mock function with given fields: class
func (_m *SchemaReader) ClassInfo(class string) schema.ClassInfo {
	ret := _m.Called(class)

	if len(ret) == 0 {
		panic("no return value specified for ClassInfo")
	}

	var r0 schema.ClassInfo
	if rf, ok := ret.Get(0).(func(string) schema.ClassInfo); ok {
		r0 = rf(class)
	} else {
		r0 = ret.Get(0).(schema.ClassInfo)
	}

	return r0
}

// SchemaReader_ClassInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClassInfo'
type SchemaReader_ClassInfo_Call struct {
	*mock.Call
}

// ClassInfo is a helper method to define mock.On call
//   - class string
func (_e *SchemaReader_Expecter) ClassInfo(class interface{}) *SchemaReader_ClassInfo_Call {
	return &SchemaReader_ClassInfo_Call{Call: _e.mock.On("ClassInfo", class)}
}

func (_c *SchemaReader_ClassInfo_Call) Run(run func(class string)) *SchemaReader_ClassInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *SchemaReader_ClassInfo_Call) Return(ci schema.ClassInfo) *SchemaReader_ClassInfo_Call {
	_c.Call.Return(ci)
	return _c
}

func (_c *SchemaReader_ClassInfo_Call) RunAndReturn(run func(string) schema.ClassInfo) *SchemaReader_ClassInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ClassInfoWithVersion provides a mock function with given fields: ctx, class, version
func (_m *SchemaReader) ClassInfoWithVersion(ctx context.Context, class string, version uint64) (schema.ClassInfo, error) {
	ret := _m.Called(ctx, class, version)

	if len(ret) == 0 {
		panic("no return value specified for ClassInfoWithVersion")
	}

	var r0 schema.ClassInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64) (schema.ClassInfo, error)); ok {
		return rf(ctx, class, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64) schema.ClassInfo); ok {
		r0 = rf(ctx, class, version)
	} else {
		r0 = ret.Get(0).(schema.ClassInfo)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uint64) error); ok {
		r1 = rf(ctx, class, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SchemaReader_ClassInfoWithVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClassInfoWithVersion'
type SchemaReader_ClassInfoWithVersion_Call struct {
	*mock.Call
}

// ClassInfoWithVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - class string
//   - version uint64
func (_e *SchemaReader_Expecter) ClassInfoWithVersion(ctx interface{}, class interface{}, version interface{}) *SchemaReader_ClassInfoWithVersion_Call {
	return &SchemaReader_ClassInfoWithVersion_Call{Call: _e.mock.On("ClassInfoWithVersion", ctx, class, version)}
}

func (_c *SchemaReader_ClassInfoWithVersion_Call) Run(run func(ctx context.Context, class string, version uint64)) *SchemaReader_ClassInfoWithVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64))
	})
	return _c
}

func (_c *SchemaReader_ClassInfoWithVersion_Call) Return(_a0 schema.ClassInfo, _a1 error) *SchemaReader_ClassInfoWithVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SchemaReader_ClassInfoWithVersion_Call) RunAndReturn(run func(context.Context, string, uint64) (schema.ClassInfo, error)) *SchemaReader_ClassInfoWithVersion_Call {
	_c.Call.Return(run)
	return _c
}

// CopyShardingState provides a mock function with given fields: class
func (_m *SchemaReader) CopyShardingState(class string) *sharding.State {
	ret := _m.Called(class)

	if len(ret) == 0 {
		panic("no return value specified for CopyShardingState")
	}

	var r0 *sharding.State
	if rf, ok := ret.Get(0).(func(string) *sharding.State); ok {
		r0 = rf(class)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sharding.State)
		}
	}

	return r0
}

// SchemaReader_CopyShardingState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyShardingState'
type SchemaReader_CopyShardingState_Call struct {
	*mock.Call
}

// CopyShardingState is a helper method to define mock.On call
//   - class string
func (_e *SchemaReader_Expecter) CopyShardingState(class interface{}) *SchemaReader_CopyShardingState_Call {
	return &SchemaReader_CopyShardingState_Call{Call: _e.mock.On("CopyShardingState", class)}
}

func (_c *SchemaReader_CopyShardingState_Call) Run(run func(class string)) *SchemaReader_CopyShardingState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *SchemaReader_CopyShardingState_Call) Return(_a0 *sharding.State) *SchemaReader_CopyShardingState_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SchemaReader_CopyShardingState_Call) RunAndReturn(run func(string) *sharding.State) *SchemaReader_CopyShardingState_Call {
	_c.Call.Return(run)
	return _c
}

// CopyShardingStateWithVersion provides a mock function with given fields: ctx, class, version
func (_m *SchemaReader) CopyShardingStateWithVersion(ctx context.Context, class string, version uint64) (*sharding.State, error) {
	ret := _m.Called(ctx, class, version)

	if len(ret) == 0 {
		panic("no return value specified for CopyShardingStateWithVersion")
	}

	var r0 *sharding.State
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64) (*sharding.State, error)); ok {
		return rf(ctx, class, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64) *sharding.State); ok {
		r0 = rf(ctx, class, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sharding.State)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uint64) error); ok {
		r1 = rf(ctx, class, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SchemaReader_CopyShardingStateWithVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyShardingStateWithVersion'
type SchemaReader_CopyShardingStateWithVersion_Call struct {
	*mock.Call
}

// CopyShardingStateWithVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - class string
//   - version uint64
func (_e *SchemaReader_Expecter) CopyShardingStateWithVersion(ctx interface{}, class interface{}, version interface{}) *SchemaReader_CopyShardingStateWithVersion_Call {
	return &SchemaReader_CopyShardingStateWithVersion_Call{Call: _e.mock.On("CopyShardingStateWithVersion", ctx, class, version)}
}

func (_c *SchemaReader_CopyShardingStateWithVersion_Call) Run(run func(ctx context.Context, class string, version uint64)) *SchemaReader_CopyShardingStateWithVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64))
	})
	return _c
}

func (_c *SchemaReader_CopyShardingStateWithVersion_Call) Return(_a0 *sharding.State, _a1 error) *SchemaReader_CopyShardingStateWithVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SchemaReader_CopyShardingStateWithVersion_Call) RunAndReturn(run func(context.Context, string, uint64) (*sharding.State, error)) *SchemaReader_CopyShardingStateWithVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetShardsStatus provides a mock function with given fields: class, tenant
func (_m *SchemaReader) GetShardsStatus(class string, tenant string) (models.ShardStatusList, error) {
	ret := _m.Called(class, tenant)

	if len(ret) == 0 {
		panic("no return value specified for GetShardsStatus")
	}

	var r0 models.ShardStatusList
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (models.ShardStatusList, error)); ok {
		return rf(class, tenant)
	}
	if rf, ok := ret.Get(0).(func(string, string) models.ShardStatusList); ok {
		r0 = rf(class, tenant)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(models.ShardStatusList)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(class, tenant)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SchemaReader_GetShardsStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetShardsStatus'
type SchemaReader_GetShardsStatus_Call struct {
	*mock.Call
}

// GetShardsStatus is a helper method to define mock.On call
//   - class string
//   - tenant string
func (_e *SchemaReader_Expecter) GetShardsStatus(class interface{}, tenant interface{}) *SchemaReader_GetShardsStatus_Call {
	return &SchemaReader_GetShardsStatus_Call{Call: _e.mock.On("GetShardsStatus", class, tenant)}
}

func (_c *SchemaReader_GetShardsStatus_Call) Run(run func(class string, tenant string)) *SchemaReader_GetShardsStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *SchemaReader_GetShardsStatus_Call) Return(_a0 models.ShardStatusList, _a1 error) *SchemaReader_GetShardsStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SchemaReader_GetShardsStatus_Call) RunAndReturn(run func(string, string) (models.ShardStatusList, error)) *SchemaReader_GetShardsStatus_Call {
	_c.Call.Return(run)
	return _c
}

// MultiTenancy provides a mock function with given fields: class
func (_m *SchemaReader) MultiTenancy(class string) models.MultiTenancyConfig {
	ret := _m.Called(class)

	if len(ret) == 0 {
		panic("no return value specified for MultiTenancy")
	}

	var r0 models.MultiTenancyConfig
	if rf, ok := ret.Get(0).(func(string) models.MultiTenancyConfig); ok {
		r0 = rf(class)
	} else {
		r0 = ret.Get(0).(models.MultiTenancyConfig)
	}

	return r0
}

// SchemaReader_MultiTenancy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MultiTenancy'
type SchemaReader_MultiTenancy_Call struct {
	*mock.Call
}

// MultiTenancy is a helper method to define mock.On call
//   - class string
func (_e *SchemaReader_Expecter) MultiTenancy(class interface{}) *SchemaReader_MultiTenancy_Call {
	return &SchemaReader_MultiTenancy_Call{Call: _e.mock.On("MultiTenancy", class)}
}

func (_c *SchemaReader_MultiTenancy_Call) Run(run func(class string)) *SchemaReader_MultiTenancy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *SchemaReader_MultiTenancy_Call) Return(_a0 models.MultiTenancyConfig) *SchemaReader_MultiTenancy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SchemaReader_MultiTenancy_Call) RunAndReturn(run func(string) models.MultiTenancyConfig) *SchemaReader_MultiTenancy_Call {
	_c.Call.Return(run)
	return _c
}

// MultiTenancyWithVersion provides a mock function with given fields: ctx, class, version
func (_m *SchemaReader) MultiTenancyWithVersion(ctx context.Context, class string, version uint64) (models.MultiTenancyConfig, error) {
	ret := _m.Called(ctx, class, version)

	if len(ret) == 0 {
		panic("no return value specified for MultiTenancyWithVersion")
	}

	var r0 models.MultiTenancyConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64) (models.MultiTenancyConfig, error)); ok {
		return rf(ctx, class, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64) models.MultiTenancyConfig); ok {
		r0 = rf(ctx, class, version)
	} else {
		r0 = ret.Get(0).(models.MultiTenancyConfig)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uint64) error); ok {
		r1 = rf(ctx, class, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SchemaReader_MultiTenancyWithVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MultiTenancyWithVersion'
type SchemaReader_MultiTenancyWithVersion_Call struct {
	*mock.Call
}

// MultiTenancyWithVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - class string
//   - version uint64
func (_e *SchemaReader_Expecter) MultiTenancyWithVersion(ctx interface{}, class interface{}, version interface{}) *SchemaReader_MultiTenancyWithVersion_Call {
	return &SchemaReader_MultiTenancyWithVersion_Call{Call: _e.mock.On("MultiTenancyWithVersion", ctx, class, version)}
}

func (_c *SchemaReader_MultiTenancyWithVersion_Call) Run(run func(ctx context.Context, class string, version uint64)) *SchemaReader_MultiTenancyWithVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64))
	})
	return _c
}

func (_c *SchemaReader_MultiTenancyWithVersion_Call) Return(_a0 models.MultiTenancyConfig, _a1 error) *SchemaReader_MultiTenancyWithVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SchemaReader_MultiTenancyWithVersion_Call) RunAndReturn(run func(context.Context, string, uint64) (models.MultiTenancyConfig, error)) *SchemaReader_MultiTenancyWithVersion_Call {
	_c.Call.Return(run)
	return _c
}

// Read provides a mock function with given fields: class, reader
func (_m *SchemaReader) Read(class string, reader func(*models.Class, *sharding.State) error) error {
	ret := _m.Called(class, reader)

	if len(ret) == 0 {
		panic("no return value specified for Read")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, func(*models.Class, *sharding.State) error) error); ok {
		r0 = rf(class, reader)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SchemaReader_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type SchemaReader_Read_Call struct {
	*mock.Call
}

// Read is a helper method to define mock.On call
//   - class string
//   - reader func(*models.Class , *sharding.State) error
func (_e *SchemaReader_Expecter) Read(class interface{}, reader interface{}) *SchemaReader_Read_Call {
	return &SchemaReader_Read_Call{Call: _e.mock.On("Read", class, reader)}
}

func (_c *SchemaReader_Read_Call) Run(run func(class string, reader func(*models.Class, *sharding.State) error)) *SchemaReader_Read_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(func(*models.Class, *sharding.State) error))
	})
	return _c
}

func (_c *SchemaReader_Read_Call) Return(_a0 error) *SchemaReader_Read_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SchemaReader_Read_Call) RunAndReturn(run func(string, func(*models.Class, *sharding.State) error) error) *SchemaReader_Read_Call {
	_c.Call.Return(run)
	return _c
}

// ReadOnlyClass provides a mock function with given fields: name
func (_m *SchemaReader) ReadOnlyClass(name string) *models.Class {
	ret := _m.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for ReadOnlyClass")
	}

	var r0 *models.Class
	if rf, ok := ret.Get(0).(func(string) *models.Class); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Class)
		}
	}

	return r0
}

// SchemaReader_ReadOnlyClass_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadOnlyClass'
type SchemaReader_ReadOnlyClass_Call struct {
	*mock.Call
}

// ReadOnlyClass is a helper method to define mock.On call
//   - name string
func (_e *SchemaReader_Expecter) ReadOnlyClass(name interface{}) *SchemaReader_ReadOnlyClass_Call {
	return &SchemaReader_ReadOnlyClass_Call{Call: _e.mock.On("ReadOnlyClass", name)}
}

func (_c *SchemaReader_ReadOnlyClass_Call) Run(run func(name string)) *SchemaReader_ReadOnlyClass_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *SchemaReader_ReadOnlyClass_Call) Return(_a0 *models.Class) *SchemaReader_ReadOnlyClass_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SchemaReader_ReadOnlyClass_Call) RunAndReturn(run func(string) *models.Class) *SchemaReader_ReadOnlyClass_Call {
	_c.Call.Return(run)
	return _c
}

// ReadOnlyClassWithVersion provides a mock function with given fields: ctx, class, version
func (_m *SchemaReader) ReadOnlyClassWithVersion(ctx context.Context, class string, version uint64) (*models.Class, error) {
	ret := _m.Called(ctx, class, version)

	if len(ret) == 0 {
		panic("no return value specified for ReadOnlyClassWithVersion")
	}

	var r0 *models.Class
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64) (*models.Class, error)); ok {
		return rf(ctx, class, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64) *models.Class); ok {
		r0 = rf(ctx, class, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Class)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uint64) error); ok {
		r1 = rf(ctx, class, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SchemaReader_ReadOnlyClassWithVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadOnlyClassWithVersion'
type SchemaReader_ReadOnlyClassWithVersion_Call struct {
	*mock.Call
}

// ReadOnlyClassWithVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - class string
//   - version uint64
func (_e *SchemaReader_Expecter) ReadOnlyClassWithVersion(ctx interface{}, class interface{}, version interface{}) *SchemaReader_ReadOnlyClassWithVersion_Call {
	return &SchemaReader_ReadOnlyClassWithVersion_Call{Call: _e.mock.On("ReadOnlyClassWithVersion", ctx, class, version)}
}

func (_c *SchemaReader_ReadOnlyClassWithVersion_Call) Run(run func(ctx context.Context, class string, version uint64)) *SchemaReader_ReadOnlyClassWithVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64))
	})
	return _c
}

func (_c *SchemaReader_ReadOnlyClassWithVersion_Call) Return(_a0 *models.Class, _a1 error) *SchemaReader_ReadOnlyClassWithVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SchemaReader_ReadOnlyClassWithVersion_Call) RunAndReturn(run func(context.Context, string, uint64) (*models.Class, error)) *SchemaReader_ReadOnlyClassWithVersion_Call {
	_c.Call.Return(run)
	return _c
}

// ReadOnlySchema provides a mock function with no fields
func (_m *SchemaReader) ReadOnlySchema() models.Schema {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ReadOnlySchema")
	}

	var r0 models.Schema
	if rf, ok := ret.Get(0).(func() models.Schema); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Schema)
	}

	return r0
}

// SchemaReader_ReadOnlySchema_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadOnlySchema'
type SchemaReader_ReadOnlySchema_Call struct {
	*mock.Call
}

// ReadOnlySchema is a helper method to define mock.On call
func (_e *SchemaReader_Expecter) ReadOnlySchema() *SchemaReader_ReadOnlySchema_Call {
	return &SchemaReader_ReadOnlySchema_Call{Call: _e.mock.On("ReadOnlySchema")}
}

func (_c *SchemaReader_ReadOnlySchema_Call) Run(run func()) *SchemaReader_ReadOnlySchema_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *SchemaReader_ReadOnlySchema_Call) Return(_a0 models.Schema) *SchemaReader_ReadOnlySchema_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SchemaReader_ReadOnlySchema_Call) RunAndReturn(run func() models.Schema) *SchemaReader_ReadOnlySchema_Call {
	_c.Call.Return(run)
	return _c
}

// ReadOnlyVersionedClass provides a mock function with given fields: name
func (_m *SchemaReader) ReadOnlyVersionedClass(name string) versioned.Class {
	ret := _m.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for ReadOnlyVersionedClass")
	}

	var r0 versioned.Class
	if rf, ok := ret.Get(0).(func(string) versioned.Class); ok {
		r0 = rf(name)
	} else {
		r0 = ret.Get(0).(versioned.Class)
	}

	return r0
}

// SchemaReader_ReadOnlyVersionedClass_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadOnlyVersionedClass'
type SchemaReader_ReadOnlyVersionedClass_Call struct {
	*mock.Call
}

// ReadOnlyVersionedClass is a helper method to define mock.On call
//   - name string
func (_e *SchemaReader_Expecter) ReadOnlyVersionedClass(name interface{}) *SchemaReader_ReadOnlyVersionedClass_Call {
	return &SchemaReader_ReadOnlyVersionedClass_Call{Call: _e.mock.On("ReadOnlyVersionedClass", name)}
}

func (_c *SchemaReader_ReadOnlyVersionedClass_Call) Run(run func(name string)) *SchemaReader_ReadOnlyVersionedClass_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *SchemaReader_ReadOnlyVersionedClass_Call) Return(_a0 versioned.Class) *SchemaReader_ReadOnlyVersionedClass_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SchemaReader_ReadOnlyVersionedClass_Call) RunAndReturn(run func(string) versioned.Class) *SchemaReader_ReadOnlyVersionedClass_Call {
	_c.Call.Return(run)
	return _c
}

// ShardFromUUID provides a mock function with given fields: class, uuid
func (_m *SchemaReader) ShardFromUUID(class string, uuid []byte) string {
	ret := _m.Called(class, uuid)

	if len(ret) == 0 {
		panic("no return value specified for ShardFromUUID")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string, []byte) string); ok {
		r0 = rf(class, uuid)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// SchemaReader_ShardFromUUID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShardFromUUID'
type SchemaReader_ShardFromUUID_Call struct {
	*mock.Call
}

// ShardFromUUID is a helper method to define mock.On call
//   - class string
//   - uuid []byte
func (_e *SchemaReader_Expecter) ShardFromUUID(class interface{}, uuid interface{}) *SchemaReader_ShardFromUUID_Call {
	return &SchemaReader_ShardFromUUID_Call{Call: _e.mock.On("ShardFromUUID", class, uuid)}
}

func (_c *SchemaReader_ShardFromUUID_Call) Run(run func(class string, uuid []byte)) *SchemaReader_ShardFromUUID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]byte))
	})
	return _c
}

func (_c *SchemaReader_ShardFromUUID_Call) Return(_a0 string) *SchemaReader_ShardFromUUID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SchemaReader_ShardFromUUID_Call) RunAndReturn(run func(string, []byte) string) *SchemaReader_ShardFromUUID_Call {
	_c.Call.Return(run)
	return _c
}

// ShardFromUUIDWithVersion provides a mock function with given fields: ctx, class, uuid, version
func (_m *SchemaReader) ShardFromUUIDWithVersion(ctx context.Context, class string, uuid []byte, version uint64) (string, error) {
	ret := _m.Called(ctx, class, uuid, version)

	if len(ret) == 0 {
		panic("no return value specified for ShardFromUUIDWithVersion")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []byte, uint64) (string, error)); ok {
		return rf(ctx, class, uuid, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []byte, uint64) string); ok {
		r0 = rf(ctx, class, uuid, version)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []byte, uint64) error); ok {
		r1 = rf(ctx, class, uuid, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SchemaReader_ShardFromUUIDWithVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShardFromUUIDWithVersion'
type SchemaReader_ShardFromUUIDWithVersion_Call struct {
	*mock.Call
}

// ShardFromUUIDWithVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - class string
//   - uuid []byte
//   - version uint64
func (_e *SchemaReader_Expecter) ShardFromUUIDWithVersion(ctx interface{}, class interface{}, uuid interface{}, version interface{}) *SchemaReader_ShardFromUUIDWithVersion_Call {
	return &SchemaReader_ShardFromUUIDWithVersion_Call{Call: _e.mock.On("ShardFromUUIDWithVersion", ctx, class, uuid, version)}
}

func (_c *SchemaReader_ShardFromUUIDWithVersion_Call) Run(run func(ctx context.Context, class string, uuid []byte, version uint64)) *SchemaReader_ShardFromUUIDWithVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]byte), args[3].(uint64))
	})
	return _c
}

func (_c *SchemaReader_ShardFromUUIDWithVersion_Call) Return(_a0 string, _a1 error) *SchemaReader_ShardFromUUIDWithVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SchemaReader_ShardFromUUIDWithVersion_Call) RunAndReturn(run func(context.Context, string, []byte, uint64) (string, error)) *SchemaReader_ShardFromUUIDWithVersion_Call {
	_c.Call.Return(run)
	return _c
}

// ShardOwner provides a mock function with given fields: class, shard
func (_m *SchemaReader) ShardOwner(class string, shard string) (string, error) {
	ret := _m.Called(class, shard)

	if len(ret) == 0 {
		panic("no return value specified for ShardOwner")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (string, error)); ok {
		return rf(class, shard)
	}
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(class, shard)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(class, shard)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SchemaReader_ShardOwner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShardOwner'
type SchemaReader_ShardOwner_Call struct {
	*mock.Call
}

// ShardOwner is a helper method to define mock.On call
//   - class string
//   - shard string
func (_e *SchemaReader_Expecter) ShardOwner(class interface{}, shard interface{}) *SchemaReader_ShardOwner_Call {
	return &SchemaReader_ShardOwner_Call{Call: _e.mock.On("ShardOwner", class, shard)}
}

func (_c *SchemaReader_ShardOwner_Call) Run(run func(class string, shard string)) *SchemaReader_ShardOwner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *SchemaReader_ShardOwner_Call) Return(_a0 string, _a1 error) *SchemaReader_ShardOwner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SchemaReader_ShardOwner_Call) RunAndReturn(run func(string, string) (string, error)) *SchemaReader_ShardOwner_Call {
	_c.Call.Return(run)
	return _c
}

// ShardOwnerWithVersion provides a mock function with given fields: ctx, lass, shard, version
func (_m *SchemaReader) ShardOwnerWithVersion(ctx context.Context, lass string, shard string, version uint64) (string, error) {
	ret := _m.Called(ctx, lass, shard, version)

	if len(ret) == 0 {
		panic("no return value specified for ShardOwnerWithVersion")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint64) (string, error)); ok {
		return rf(ctx, lass, shard, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint64) string); ok {
		r0 = rf(ctx, lass, shard, version)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, uint64) error); ok {
		r1 = rf(ctx, lass, shard, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SchemaReader_ShardOwnerWithVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShardOwnerWithVersion'
type SchemaReader_ShardOwnerWithVersion_Call struct {
	*mock.Call
}

// ShardOwnerWithVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - lass string
//   - shard string
//   - version uint64
func (_e *SchemaReader_Expecter) ShardOwnerWithVersion(ctx interface{}, lass interface{}, shard interface{}, version interface{}) *SchemaReader_ShardOwnerWithVersion_Call {
	return &SchemaReader_ShardOwnerWithVersion_Call{Call: _e.mock.On("ShardOwnerWithVersion", ctx, lass, shard, version)}
}

func (_c *SchemaReader_ShardOwnerWithVersion_Call) Run(run func(ctx context.Context, lass string, shard string, version uint64)) *SchemaReader_ShardOwnerWithVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(uint64))
	})
	return _c
}

func (_c *SchemaReader_ShardOwnerWithVersion_Call) Return(_a0 string, _a1 error) *SchemaReader_ShardOwnerWithVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SchemaReader_ShardOwnerWithVersion_Call) RunAndReturn(run func(context.Context, string, string, uint64) (string, error)) *SchemaReader_ShardOwnerWithVersion_Call {
	_c.Call.Return(run)
	return _c
}

// ShardReplicas provides a mock function with given fields: class, shard
func (_m *SchemaReader) ShardReplicas(class string, shard string) ([]string, error) {
	ret := _m.Called(class, shard)

	if len(ret) == 0 {
		panic("no return value specified for ShardReplicas")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) ([]string, error)); ok {
		return rf(class, shard)
	}
	if rf, ok := ret.Get(0).(func(string, string) []string); ok {
		r0 = rf(class, shard)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(class, shard)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SchemaReader_ShardReplicas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShardReplicas'
type SchemaReader_ShardReplicas_Call struct {
	*mock.Call
}

// ShardReplicas is a helper method to define mock.On call
//   - class string
//   - shard string
func (_e *SchemaReader_Expecter) ShardReplicas(class interface{}, shard interface{}) *SchemaReader_ShardReplicas_Call {
	return &SchemaReader_ShardReplicas_Call{Call: _e.mock.On("ShardReplicas", class, shard)}
}

func (_c *SchemaReader_ShardReplicas_Call) Run(run func(class string, shard string)) *SchemaReader_ShardReplicas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *SchemaReader_ShardReplicas_Call) Return(_a0 []string, _a1 error) *SchemaReader_ShardReplicas_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SchemaReader_ShardReplicas_Call) RunAndReturn(run func(string, string) ([]string, error)) *SchemaReader_ShardReplicas_Call {
	_c.Call.Return(run)
	return _c
}

// ShardReplicasWithVersion provides a mock function with given fields: ctx, class, shard, version
func (_m *SchemaReader) ShardReplicasWithVersion(ctx context.Context, class string, shard string, version uint64) ([]string, error) {
	ret := _m.Called(ctx, class, shard, version)

	if len(ret) == 0 {
		panic("no return value specified for ShardReplicasWithVersion")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint64) ([]string, error)); ok {
		return rf(ctx, class, shard, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint64) []string); ok {
		r0 = rf(ctx, class, shard, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, uint64) error); ok {
		r1 = rf(ctx, class, shard, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SchemaReader_ShardReplicasWithVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShardReplicasWithVersion'
type SchemaReader_ShardReplicasWithVersion_Call struct {
	*mock.Call
}

// ShardReplicasWithVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - class string
//   - shard string
//   - version uint64
func (_e *SchemaReader_Expecter) ShardReplicasWithVersion(ctx interface{}, class interface{}, shard interface{}, version interface{}) *SchemaReader_ShardReplicasWithVersion_Call {
	return &SchemaReader_ShardReplicasWithVersion_Call{Call: _e.mock.On("ShardReplicasWithVersion", ctx, class, shard, version)}
}

func (_c *SchemaReader_ShardReplicasWithVersion_Call) Run(run func(ctx context.Context, class string, shard string, version uint64)) *SchemaReader_ShardReplicasWithVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(uint64))
	})
	return _c
}

func (_c *SchemaReader_ShardReplicasWithVersion_Call) Return(_a0 []string, _a1 error) *SchemaReader_ShardReplicasWithVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SchemaReader_ShardReplicasWithVersion_Call) RunAndReturn(run func(context.Context, string, string, uint64) ([]string, error)) *SchemaReader_ShardReplicasWithVersion_Call {
	_c.Call.Return(run)
	return _c
}

// TenantsShardsWithVersion provides a mock function with given fields: ctx, version, class, tenants
func (_m *SchemaReader) TenantsShardsWithVersion(ctx context.Context, version uint64, class string, tenants ...string) (map[string]string, error) {
	_va := make([]interface{}, len(tenants))
	for _i := range tenants {
		_va[_i] = tenants[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, version, class)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TenantsShardsWithVersion")
	}

	var r0 map[string]string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string, ...string) (map[string]string, error)); ok {
		return rf(ctx, version, class, tenants...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string, ...string) map[string]string); ok {
		r0 = rf(ctx, version, class, tenants...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, string, ...string) error); ok {
		r1 = rf(ctx, version, class, tenants...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SchemaReader_TenantsShardsWithVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TenantsShardsWithVersion'
type SchemaReader_TenantsShardsWithVersion_Call struct {
	*mock.Call
}

// TenantsShardsWithVersion is a helper method to define mock.On call
//   - ctx context.Context
//   - version uint64
//   - class string
//   - tenants ...string
func (_e *SchemaReader_Expecter) TenantsShardsWithVersion(ctx interface{}, version interface{}, class interface{}, tenants ...interface{}) *SchemaReader_TenantsShardsWithVersion_Call {
	return &SchemaReader_TenantsShardsWithVersion_Call{Call: _e.mock.On("TenantsShardsWithVersion",
		append([]interface{}{ctx, version, class}, tenants...)...)}
}

func (_c *SchemaReader_TenantsShardsWithVersion_Call) Run(run func(ctx context.Context, version uint64, class string, tenants ...string)) *SchemaReader_TenantsShardsWithVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(uint64), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *SchemaReader_TenantsShardsWithVersion_Call) Return(_a0 map[string]string, _a1 error) *SchemaReader_TenantsShardsWithVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *SchemaReader_TenantsShardsWithVersion_Call) RunAndReturn(run func(context.Context, uint64, string, ...string) (map[string]string, error)) *SchemaReader_TenantsShardsWithVersion_Call {
	_c.Call.Return(run)
	return _c
}

// WaitForUpdate provides a mock function with given fields: ctx, version
func (_m *SchemaReader) WaitForUpdate(ctx context.Context, version uint64) error {
	ret := _m.Called(ctx, version)

	if len(ret) == 0 {
		panic("no return value specified for WaitForUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64) error); ok {
		r0 = rf(ctx, version)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SchemaReader_WaitForUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitForUpdate'
type SchemaReader_WaitForUpdate_Call struct {
	*mock.Call
}

// WaitForUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - version uint64
func (_e *SchemaReader_Expecter) WaitForUpdate(ctx interface{}, version interface{}) *SchemaReader_WaitForUpdate_Call {
	return &SchemaReader_WaitForUpdate_Call{Call: _e.mock.On("WaitForUpdate", ctx, version)}
}

func (_c *SchemaReader_WaitForUpdate_Call) Run(run func(ctx context.Context, version uint64)) *SchemaReader_WaitForUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64))
	})
	return _c
}

func (_c *SchemaReader_WaitForUpdate_Call) Return(_a0 error) *SchemaReader_WaitForUpdate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *SchemaReader_WaitForUpdate_Call) RunAndReturn(run func(context.Context, uint64) error) *SchemaReader_WaitForUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// NewSchemaReader creates a new instance of SchemaReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSchemaReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *SchemaReader {
	mock := &SchemaReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
